on:
  push:
    branches: [ "dev" ]
  pull_request:
    branches: [ "dev" ]

concurrency:
  group: ${{ github.ref_name }}


env:
  AWS_REGION: "us-east-2"
  FRONTEND_REPOSITORY_NAME: "frontend"
  BACKEND_REPOSITORY_NAME: "backend"
  BACKEND_PROXY_REPOSITORY_NAME: "proxy"
  ECR_REPOSITORY_URL: "454624638483.dkr.ecr.us-east-2.amazonaws.com"
  ENVIRONMENT: ${{ github.ref_name }}
  PROXY_PORT: 80
  APP_PORT: 8080
  APP_HOST: localhost

jobs:
  changes:
    name: "Routing"
    runs-on: ubuntu-latest  # windows-latest | macos-latest
    steps:

      - name: Download repository...
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # OR "2" -> To retrieve the preceding commit.

      - name: Check changed directories...
        id: changed-files-dir-names
        uses: tj-actions/changed-files@v29.0.2
        with:
          dir_names: "true"

      - name: List all changed directories...
        run: |
          for directory in ${{ steps.changed-files-dir-names.outputs.all_changed_and_modified_files }}; do
            echo "$directory was changed"
          done

      - name: Get short commit id
        id: sha
        run: echo "::set-output name=short::$(git rev-parse --short HEAD)"

      - name: Setup terraform 
        uses: hashicorp/setup-terraform@v2
        run:
          output=$(terraform output cloudfront)
          echo $output

    outputs:
      changed_directories: ${{ steps.changed-files-dir-names.outputs.all_changed_and_modified_files }}
      short_sha: ${{ steps.sha.outputs.short }}
      
  infrastructure:
    name: Infrastructure
    needs: changes
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.changes.result == 'success' &&
      contains(needs.changes.outputs.changed_directories, 'infrastructure')
    steps:
      - name: Download repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # OR "2" -> To retrieve the preceding commit.

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update backend app TF variables
        env:
          FILTER_TAG: "latest"

        run: |
          echo "Getting backend app images ids..."
          
          BACKEND_APP_IMAGES_IDS=$(aws ecr list-images \
          --repository-name "${BACKEND_REPOSITORY_NAME}" \
          --region "${AWS_REGION}" \
          | jq '.imageIds | length')

          echo "Backend app images ids: ${BACKEND_APP_IMAGES_IDS}"

          if [[ ${BACKEND_APP_IMAGES_IDS} -gt 0 ]]
          then
            echo "Get image with tag: ${FILTER_TAG}"
            
            backend_app_images=$(aws ecr describe-images \
            --repository-name "${BACKEND_REPOSITORY_NAME}" \
            --image-ids imageTag="${FILTER_TAG}" \
            --region "${AWS_REGION}")
            
            echo "Image is: ${backend_app_images}"

            echo "Getting tag from latest image..."
            
            tag=$(echo "$backend_app_images" \
            | jq '.imageDetails[].imageTags' \
            | jq --arg BRANCH "${{ github.ref_name }}" --arg FILTER "${FILTER_TAG}" 'del(.[] | select(. == $BRANCH or . == $FILTER))[]' \
            | tr -d '"' \
            | tail -n1)

            if [[ $(echo $tag | wc -l) -gt 0 ]]
            then
              echo "buildBackendAppImage=false" >> "$GITHUB_ENV"
              echo "Tag is: ${tag} so no need to build the image..."
              echo "Set tag ${tag} in Terraform environment variables..."
              echo "TF_VAR_backend_app_container_image_tag=${tag}" >> "$GITHUB_ENV"
            else
              echo "Latest tag does not exits, something wrong, exiting..."
              exit 1
            fi
          else
              echo "There are no images, will build one..."
              echo "buildBackendAppImage=true" >> "$GITHUB_ENV"
              echo "Set tag: ${{ needs.changes.outputs.short_sha }} to Terraform environment variables..."
              echo "TF_VAR_backend_app_container_image_tag=${{ needs.changes.outputs.short_sha }}" >> "$GITHUB_ENV"
          fi

      - name: Update proxy TF variables
        env:
          FILTER_TAG: "latest"

        run: |
          echo "Getting backend proxy images ids..."
          
          BACKEND_PROXY_IMAGES_IDS=$(aws ecr list-images \
          --repository-name "${BACKEND_PROXY_REPOSITORY_NAME}" \
          --region "${AWS_REGION}" \
          | jq '.imageIds | length')
          
          echo "Backend proxy images ids: ${BACKEND_PROXY_IMAGES_IDS}"

          if [[ ${BACKEND_PROXY_IMAGES_IDS} -gt 0 ]]
          then
            echo "Some images already exist, getting them by tag: ${FILTER_TAG}"
            
            backend_proxy_images=$(aws ecr describe-images \
            --repository-name "${BACKEND_PROXY_REPOSITORY_NAME}" \
            --image-ids imageTag="${FILTER_TAG}" \
            --region "${AWS_REGION}")
            
            echo "Images are: ${backend_proxy_images}"
            
            echo "Getting tag from latest image..."
            tag=$(echo "$backend_proxy_images" \
            | jq '.imageDetails[].imageTags' \
            | jq --arg BRANCH "${{ github.ref_name }}" --arg FILTER "${FILTER_TAG}" 'del(.[] | select(. == $BRANCH or . == $FILTER))[]' \
            | tr -d '"' \
            | tail -n1)

            if [[ $(echo $tag | wc -l) -gt 0 ]]
            then
              echo "Image already exists, tag is ${tag}"
              echo "buildBackendProxyImage=false" >> "$GITHUB_ENV"
              echo "Set tag ${tag} in Terraform environment variables..."
              echo "TF_VAR_backend_proxy_container_image_tag=${tag}" >> "$GITHUB_ENV"
            else
              echo "Latest tag does not exits, something wrong, exiting..."
              exit 1
            fi
          else
            echo "Proxy image does not exists, will build one..."
            echo "buildBackendProxyImage=true" >> "$GITHUB_ENV"
            echo "Set tag ${{ needs.changes.outputs.short_sha }} in Terraform environment variables..."
            echo "TF_VAR_backend_proxy_container_image_tag=${{ needs.changes.outputs.short_sha }}" >> "$GITHUB_ENV"
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
        if: env.buildBackendAppImage == 'true' || env.buildBackendProxyImage == 'true'

      - name: Substitute proxy env variables
        run: envsubst <  default.conf.tpl > default.conf
        working-directory: './backend/proxy/'
        if: env.buildBackendProxyImage == 'true'

      - name: Substitute app env variables
        run: envsubst <  server.js.tpl > server.js
        working-directory: './backend/nodejs/'
        if: env.buildBackendAppImage == 'true'
      
      - name: Building app image...
        uses: docker/build-push-action@v2
        with:
          context: "./backend/nodejs/"
          file: "./backend/nodejs/Dockerfile"
          push: true
          tags: | 
            ${{ env.BACKEND_REPOSITORY_URL }}:latest
            ${{ env.BACKEND_REPOSITORY_URL }}:${{ github.ref_name }}
            ${{ env.BACKEND_REPOSITORY_URL }}:${{ needs.changes.outputs.short_sha }}
        env:
          BACKEND_REPOSITORY_URL: ${{ format('{0}/{1}', env.ECR_REPOSITORY_URL, env.BACKEND_REPOSITORY_NAME) }}
        if: env.buildBackendAppImage == 'true'

      - name: Build proxy image...
        uses: docker/build-push-action@v2
        with:
          context: "./backend/proxy"
          file: "./backend/proxy/Dockerfile"
          push: true
          tags: |
            ${{ env.BACKEND_PROXY_REPOSITORY_URL }}:latest
            ${{ env.BACKEND_PROXY_REPOSITORY_URL }}:${{ github.ref_name }}
            ${{ env.BACKEND_PROXY_REPOSITORY_URL }}:${{ needs.changes.outputs.short_sha }}
        env:
          BACKEND_PROXY_REPOSITORY_URL: ${{ format('{0}/{1}', env.ECR_REPOSITORY_URL, env.BACKEND_PROXY_REPOSITORY_NAME) }}
        if: env.buildBackendProxyImage == 'true'

      - name: Terraform plan...
        working-directory: "./infrastructure/environments/dev/"
        run: |
          terraform init
          terraform plan
      
      - name: Terraform apply...
        working-directory: "./infrastructure/environments/dev"
        run: terraform apply -auto-approve

  backend:
    name: Backend
    needs: [changes, infrastructure]
    if: |
      always() &&
      needs.changes.result == 'success' &&
      (needs.infrastructure.result == 'success' || needs.infrastructure.result == 'skipped') &&
      contains(needs.changes.outputs.changed_directories, 'backend')
    runs-on: ubuntu-latest
    env:
      FILTER_TAG: latest
    steps:

      - name: Download repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # OR "2" -> To retrieve the preceding commit.

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Substitute proxy env variables
        run: envsubst <  default.conf.tpl > default.conf
        working-directory: './backend/proxy/'
        if: contains(needs.changes.outputs.changed_directories, 'proxy')

      - name: Substitute app env variables
        run: envsubst <  server.js.tpl > server.js
        working-directory: './backend/nodejs/'
        if: contains(needs.changes.outputs.changed_directories, 'nodejs')

      - name: Build image for proxy...
        uses: docker/build-push-action@v2
        with:
          context: "./backend/proxy"
          file: "./backend/proxy/Dockerfile"
          push: true
          tags: |
            ${{ env.BACKEND_PROXY_REPOSITORY_URL }}:latest
            ${{ env.BACKEND_PROXY_REPOSITORY_URL }}:${{ github.ref_name }}
            ${{ env.BACKEND_PROXY_REPOSITORY_URL }}:${{ needs.changes.outputs.short_sha }}
        env:
          BACKEND_PROXY_REPOSITORY_URL: ${{ format('{0}/{1}', env.ECR_REPOSITORY_URL, env.BACKEND_PROXY_REPOSITORY_NAME) }}
        if: contains(needs.changes.outputs.changed_directories, 'proxy')

      - name: Build image for backend...
        uses: docker/build-push-action@v2
        with:
          context: "./backend/nodejs"
          file: "./backend/nodejs/Dockerfile"
          push: true
          tags: |
            ${{ env.BACKEND_REPOSITORY_URL }}:latest
            ${{ env.BACKEND_REPOSITORY_URL }}:${{ github.ref_name }}
            ${{ env.BACKEND_REPOSITORY_URL }}:${{ needs.changes.outputs.short_sha }}
        env:
          BACKEND_REPOSITORY_URL: ${{ format('{0}/{1}', env.ECR_REPOSITORY_URL, env.BACKEND_REPOSITORY_NAME) }}
        if: contains(needs.changes.outputs.changed_directories, 'nodejs')

      - name: Set proxy tag
        run: |
            if [[ ${{ contains(needs.changes.outputs.changed_directories, 'proxy') }} == true ]]
            then
              echo "Set tag: ${{ needs.changes.outputs.short_sha }} to Terraform variables since new image will be built..."
              echo "TF_VAR_backend_proxy_container_image_tag=${{ needs.changes.outputs.short_sha }}" >> "$GITHUB_ENV"
            else 
              echo "Getting tag from latest image..."
              backend_proxy_images=$(aws ecr describe-images \
              --repository-name "${BACKEND_PROXY_REPOSITORY_NAME}" \
              --image-ids imageTag="${FILTER_TAG}" \
              --region "${AWS_REGION}")
              tag=$(echo "$backend_proxy_images" \
              | jq '.imageDetails[].imageTags' \
              | jq --arg BRANCH "${{ github.ref_name }}" --arg FILTER "${FILTER_TAG}" 'del(.[] | select(. == $BRANCH or . == $FILTER))[]' \
              | tr -d '"' \
              | tail -n1)
              echo "Image tag is: ${tag}"
              echo "Add tag: ${tag} to Terraform environment variables..."
              echo "TF_VAR_backend_proxy_container_image_tag=${tag}" >> "$GITHUB_ENV"
            fi

      - name: Set app tag
        run: |
            if [[ ${{ contains(needs.changes.outputs.changed_directories, 'nodejs') }} == true ]]
            then
              echo "Set tag: ${{ needs.changes.outputs.short_sha }} to Terraform variables since new image will be built..."
              echo "TF_VAR_backend_app_container_image_tag=${{ needs.changes.outputs.short_sha }}" >> "$GITHUB_ENV"
            else 
              echo "Getting tag from latest image..."
              backend_app_images=$(aws ecr describe-images \
              --repository-name "${BACKEND_REPOSITORY_NAME}" \
              --image-ids imageTag="${FILTER_TAG}" \
              --region "${AWS_REGION}")
              tag=$(echo "$backend_app_images" \
              | jq '.imageDetails[].imageTags' \
              | jq --arg BRANCH "${{ github.ref_name }}" --arg FILTER "${FILTER_TAG}" 'del(.[] | select(. == $BRANCH or . == $FILTER))[]' \
              | tr -d '"' \
              | tail -n1)
              echo "Image tag is: ${tag}"
              echo "Add tag: ${tag} to Terraform environment variables..."
              echo "TF_VAR_backend_app_container_image_tag=${tag}" >> "$GITHUB_ENV"
            fi

      - name: Update backend...
        working-directory: "./infrastructure/environments/dev/"
        env:
          TF_VAR_backend_app_container_port: ${{ env.APP_PORT }}
          TF_VAR_backend_proxy_container_port: ${{ env.PROXY_PORT }}
        run: |
          echo "Updating backend image..."
          terraform init
          terraform apply -auto-approve -target module.ecs.aws_ecs_service.api -target module.ecs.aws_ecs_task_definition.api

  frontend:
    name: Frontend
    needs: [changes, infrastructure, backend]
    if: |
      always() &&
      needs.changes.result == 'success' &&
      (needs.infrastructure.result == 'success' || needs.infrastructure.result == 'skipped') &&
      (needs.backend.result == 'success' || needs.backend.result == 'skipped') &&
      contains(needs.changes.outputs.changed_directories, 'frontend')
    runs-on: ubuntu-latest
    env:
      FRONTEND_DIRECTORY: "frontend"
    steps:

      - name: Download repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # OR "2" -> To retrieve the preceding commit.

      - name: Use Node.js 16.x
        uses: actions/setup-node@v1
        with:
          node-version: 16.x

      - name: Install dependencies
        run: npm install
        working-directory: ${{ env.FRONTEND_DIRECTORY }}
      
      - name: Test
        run: npm test
        env:
          CI: true
        working-directory: ${{ env.FRONTEND_DIRECTORY }}
      
      - name: Generate build
        run: npm run build
        working-directory: ${{ env.FRONTEND_DIRECTORY }}

      - name: "Check if index.html exists..."
        id: check_files
        uses: andstor/file-existence-action@v1
        with:
          files: "./${{env.FRONTEND_DIRECTORY}}/build/index.html"

      - name: "Fail if files dont exit"
        if: steps.check_files.outputs.files_exists != 'true'
        run: |
          ls -alh ./build
          echo "./$FRONTEND_DIRECTORY/build/index.html is missing!"
          exit 1

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to S3
        run: aws s3 sync "./build/" s3://artifacts1910 --dryrun --exclude docker --delete
        working-directory: ${{ env.FRONTEND_DIRECTORY }}

      - name: Test
        run: echo ${{ env.FRONTEND_REPOSITORY_URL }}
        env:
          FRONTEND_REPOSITORY_URL: ${{ format('{0}/{1}', env.ECR_REPOSITORY_URL, env.FRONTEND_REPOSITORY_NAME) }}

      - name: Setup terraform 
        uses: hashicorp/setup-terraform@v2
        run:
          output=$(terraform output test)
          echo $output

      #- name: Invalidate Cache
      #  uses: chetan/invalidate-cloudfront-action@v2
      #  env:
      #    DISTRIBUTION: ${{ secrets.DEV_DISTRIBUTION }}
      #    PATHS: "/*"
      #    AWS_REGION: ${{ secrets.DEV_AWS_REGION }}
      #    AWS_ACCESS_KEY_ID: ${{ secrets.DEV_AWS_ACCESS_KEY_ID }}
      #    AWS_SECRET_ACCESS_KEY: ${{ secrets.DEV_AWS_SECRET_ACCESS_KEY }}
      #    DEBUG: "1"