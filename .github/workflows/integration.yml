on:
  push:
    branches: [ "dev" ]
  pull_request:
    branches: [ "dev" ]

concurrency:
  group: ${{ github.ref_name }}


env:
  AWS_REGION: "us-east-2"
  FRONTEND_REPOSITORY_NAME: "frontend"
  BACKEND_REPOSITORY_NAME: "backend"
  BACKEND_PROXY_REPOSITORY_NAME: "proxy"
  ECR_REPOSITORY_URL: "454624638483.dkr.ecr.us-east-2.amazonaws.com"

jobs:
  changes:
    name: "Analysis"
    runs-on: ubuntu-latest  # windows-latest | macos-latest
    steps:

      - name: Download repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # OR "2" -> To retrieve the preceding commit.

      - name: Check changed directories
        id: changed-files-dir-names
        uses: tj-actions/changed-files@v29.0.2
        with:
          dir_names: "true"

      - name: List all changed directories
        run: |
          for directory in ${{ steps.changed-files-dir-names.outputs.all_changed_and_modified_files }}; do
            echo "$directory was changed"
          done

      - name: Set short sha
        id: sha
        run: echo "::set-output name=short::$(git rev-parse --short HEAD)"

    outputs:
      changed_directories: ${{ steps.changed-files-dir-names.outputs.all_changed_and_modified_files }}
      short_sha: ${{ steps.sha.outputs.short }}
      
  infrastructure:
    name: Infrastructure
    needs: changes
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.changes.result == 'success' &&
      contains(needs.changes.outputs.changed_directories, 'infrastructure')
    steps:
      - name: Download repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # OR "2" -> To retrieve the preceding commit.

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update infrastructure
        env:
          FILTER_TAG: "latest"

        run: |
          echo "Getting images ids..."
          IMAGES_IDS=$(aws ecr list-images --repository-name "${BACKEND_REPOSITORY_NAME}" --region "${AWS_REGION}" | jq '.imageIds | length')

          echo "Images ids: ${IMAGES_IDS}"

          if [[ ${IMAGES_IDS} -gt 0 ]]
          then
            echo "Some images already exist, getting them..."
            images=$(aws ecr describe-images --repository-name "${BACKEND_REPOSITORY_NAME}" --image-ids imageTag="${FILTER_TAG}" --region "${AWS_REGION}")
            echo "Images are: ${images}"
            echo "Getting tag from latest image..."
            tag=$(echo "$images" | jq '.imageDetails[].imageTags' | jq 'del(.[] | select(. == "${{ github.ref_name }}" or . == "latest"))[]' | tr -d '"' | tail -n1)
            echo "Image tag is: ${tag}"

            if [[ $(echo $tag | wc -l) -gt 0 ]]
            then
              echo "Image already exists, going to Terraform!!!"
              echo "buildImage=false" >> "$GITHUB_ENV"
              echo "TF_VAR_image_tag=${tag}" >> "$GITHUB_ENV"
            else
              echo "Latest tag does not exits, something wrong, exiting..."
              exit 1
            fi
          else
              echo "There are no images, will build one..."
              echo "buildImage=true" >> "$GITHUB_ENV"
              echo "TF_VAR_image_tag=${{ steps.sha.outputs.short }}" >> "$GITHUB_ENV"
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
        if: env.buildImage == 'true'
      
      - name: Building initial image...
        uses: docker/build-push-action@v2
        with:
          context: "./backend/"
          file: "./backend/Dockerfile"
          push: true
          tags: | 
            ${{ env.BACKEND_REPOSITORY_URL }}:latest
            ${{ env.BACKEND_REPOSITORY_URL }}:${{ github.ref_name }}
            ${{ env.BACKEND_REPOSITORY_URL }}:${{ needs.changes.outputs.short_sha }}
        if: env.buildImage == 'true'
        env:
          BACKEND_REPOSITORY_URL: ${{ format('{0}/{1}', env.ECR_REPOSITORY_URL, env.BACKEND_REPOSITORY_NAME) }}

      - name: Run Terraform
        working-directory: "./infrastructure/environments/dev/"
        run: |
          echo "Running Terraform..."
          terraform init
          terraform plan
          terraform apply -auto-approve

  backend:
    name: Backend
    needs: [changes, infrastructure]
    if: |
      always() &&
      needs.changes.result == 'success' &&
      (needs.infrastructure.result == 'success' || needs.infrastructure.result == 'skipped') &&
      contains(needs.changes.outputs.changed_directories, 'backend')
    runs-on: ubuntu-latest
    steps:

      - name: Download repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # OR "2" -> To retrieve the preceding commit.

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build image for proxy...
        uses: docker/build-push-action@v2
        with:
          context: "./backend/proxy"
          file: "./backend/proxy/Dockerfile"
          push: true
          tags: |
            ${{ env.BACKEND_PROXY_REPOSITORY_URL }}:latest
            ${{ env.BACKEND_PROXY_REPOSITORY_URL }}:${{ github.ref_name }}
            ${{ env.BACKEND_PROXY_REPOSITORY_URL }}:${{ needs.changes.outputs.short_sha }}
        env:
          BACKEND_PROXY_REPOSITORY_URL: ${{ format('{0}/{1}', env.ECR_REPOSITORY_URL, env.BACKEND_PROXY_REPOSITORY_NAME) }}
        if: contains(needs.changes.outputs.changed_directories, 'proxy')

      - name: Build image for backend...
        uses: docker/build-push-action@v2
        with:
          context: "./backend/nodejs"
          file: "./backend/nodejs/Dockerfile"
          push: true
          tags: |
            ${{ env.BACKEND_REPOSITORY_URL }}:latest
            ${{ env.BACKEND_REPOSITORY_URL }}:${{ github.ref_name }}
            ${{ env.BACKEND_REPOSITORY_URL }}:${{ needs.changes.outputs.short_sha }}
        env:
          BACKEND_REPOSITORY_URL: ${{ format('{0}/{1}', env.ECR_REPOSITORY_URL, env.BACKEND_REPOSITORY_NAME) }}
        if: contains(needs.changes.outputs.changed_directories, 'nodejs')

      #- name: Update backend...
      #  working-directory: "./infrastructure/environments/dev/"
      #  env:
      #    TF_VAR_image_tag: ${{ needs.changes.outputs.short_sha }}
      #  run: |
      #    echo "Updating backend image..."
      #    terraform init
      #    terraform apply -auto-approve -target module.ecs.aws_ecs_service.api -target module.ecs.aws_ecs_task_definition.api

  frontend:
    name: Frontend
    needs: [changes, infrastructure, backend]
    if: |
      always() &&
      needs.changes.result == 'success' &&
      (needs.infrastructure.result == 'success' || needs.infrastructure.result == 'skipped') &&
      (needs.backend.result == 'success' || needs.backend.result == 'skipped') &&
      contains(needs.changes.outputs.changed_directories, 'frontend')
    runs-on: ubuntu-latest
    env:
      FRONTEND_DIRECTORY: "frontend"
    steps:

      - name: Download repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # OR "2" -> To retrieve the preceding commit.

      - name: Use Node.js 16.x
        uses: actions/setup-node@v1
        with:
          node-version: 16.x

      - name: Install dependencies
        run: npm install
        working-directory: ${{ env.FRONTEND_DIRECTORY }}
      
      - name: Test
        run: npm test
        env:
          CI: true
        working-directory: ${{ env.FRONTEND_DIRECTORY }}
      
      - name: Generate build
        run: npm run build
        working-directory: ${{ env.FRONTEND_DIRECTORY }}

      - name: "Check if index.html exists..."
        id: check_files
        uses: andstor/file-existence-action@v1
        with:
          files: "./${{env.FRONTEND_DIRECTORY}}/build/index.html"

      - name: "Fail if files dont exit"
        if: steps.check_files.outputs.files_exists != 'true'
        run: |
          ls -alh ./build
          echo "./$FRONTEND_DIRECTORY/build/index.html is missing!"
          exit 1

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to S3
        run: aws s3 sync "./build/" s3://artifacts1910 --dryrun --exclude docker --delete
        working-directory: ${{ env.FRONTEND_DIRECTORY }}

      - name: Test
        run: echo ${{ env.FRONTEND_REPOSITORY_URL }}
        env:
          FRONTEND_REPOSITORY_URL: ${{ format('{0}/{1}', env.ECR_REPOSITORY_URL, env.FRONTEND_REPOSITORY_NAME) }}

      #- name: Invalidate Cache
      #  uses: chetan/invalidate-cloudfront-action@v2
      #  env:
      #    DISTRIBUTION: ${{ secrets.DEV_DISTRIBUTION }}
      #    PATHS: "/*"
      #    AWS_REGION: ${{ secrets.DEV_AWS_REGION }}
      #    AWS_ACCESS_KEY_ID: ${{ secrets.DEV_AWS_ACCESS_KEY_ID }}
      #    AWS_SECRET_ACCESS_KEY: ${{ secrets.DEV_AWS_SECRET_ACCESS_KEY }}
      #    DEBUG: "1"