on:
  push:
    branches: [ "dev" ]
  pull_request:
    branches: [ "dev" ]

env:
  AWS_REGION: "us-east-2"
  AWS_ECR_REPOSITORY: "test"
  AWS_ECR_REPO_URL: "454624638483.dkr.ecr.us-east-2.amazonaws.com/test"

jobs:
  changes:
    name: "Changes"
    runs-on: ubuntu-latest  # windows-latest | macos-latest
    steps:

      - name: Download repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # OR "2" -> To retrieve the preceding commit.

      - name: Check changed directories
        id: changed-files-dir-names
        uses: tj-actions/changed-files@v29.0.2
        with:
          dir_names: "true"

      - name: List all changed directories
        run: |
          for directory in ${{ steps.changed-files-dir-names.outputs.all_changed_and_modified_files }}; do
            echo "$directory was changed"
          done

      - name: Set short sha
        id: sha
        run: echo "::set-output name=short::$(git rev-parse --short HEAD)"

    outputs:
      changed_directories: ${{ steps.changed-files-dir-names.outputs.all_changed_and_modified_files }}
      short_sha: ${{ steps.sha.outputs.short }}
      
  infrastructure:
    name: Infrastructure
    needs: changes
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.changes.result == 'success' &&
      contains(needs.changes.outputs.changed_directories, 'infrastructure')
    steps:
      - name: Download repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # OR "2" -> To retrieve the preceding commit.

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: "us-east-2"

      - name: Update infrastructure
        env:
          FILTER_TAG: "latest"

        run: |
          echo "Getting images ids..."
          IMAGES_IDS=$(aws ecr list-images --repository-name "${AWS_ECR_REPOSITORY}" --region "${AWS_REGION}" | jq '.imageIds | length')

          echo "Images ids: ${IMAGES_IDS}"

          if [[ ${IMAGES_IDS} -gt 0 ]]
          then
            echo "Some images already exist, getting them..."
            images=$(aws ecr describe-images --repository-name "${AWS_ECR_REPOSITORY}" --image-ids imageTag="${FILTER_TAG}" --region "${AWS_REGION}")
            echo "Images are: ${images}"
            echo "Getting tag from latest image..."
            tag=$(echo "$images" | jq '.imageDetails[].imageTags' | jq 'del(.[] | select(. == "${{ github.ref_name }}" or . == "latest"))[]' | tr -d '"' | tail -n1)
            echo "Image tag is: ${tag}"

            if [[ $(echo $tag | wc -l) -gt 0 ]]
            then
              echo "Image already exists, going to Terraform!!!"
              echo "buildImage=false" >> "$GITHUB_ENV"
              echo "TF_VAR_image_tag=${tag}" >> "$GITHUB_ENV"
            else
              echo "Latest tag does not exits, something wrong, exiting..."
              exit 1
            fi
          else
              echo "There are no images, will build one..."
              echo "buildImage=true" >> "$GITHUB_ENV"
              echo "TF_VAR_image_tag=${{ steps.sha.outputs.short }}" >> "$GITHUB_ENV"
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
        if: env.buildImage == 'true'
      
      - name: Building initial image...
        uses: docker/build-push-action@v2
        with:
          context: "./backend/"
          file: "./backend/Dockerfile"
          push: true
          tags: | 
            ${{ env.AWS_ECR_REPO_URL }}:latest
            ${{ env.AWS_ECR_REPO_URL }}:${{ github.ref_name }}
            ${{ env.AWS_ECR_REPO_URL }}:${{ needs.changes.outputs.short_sha }}
        if: env.buildImage == 'true'

      - name: Run Terraform
        working-directory: "./infrastructure/environments/dev/"
        run: |
          echo "Running Terraform..."
          terraform init
          terraform plan
          terraform apply -auto-approve

  backend:
    name: Backend
    needs: [changes, infrastructure]
    if: |
      always() &&
      needs.changes.result == 'success' &&
      (needs.infrastructure.result == 'success' || needs.infrastructure.result == 'skipped') &&
      contains(needs.changes.outputs.changed_directories, 'backend')
    runs-on: ubuntu-latest
    steps:

      - name: Download repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # OR "2" -> To retrieve the preceding commit.

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: "us-east-2"

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build image for backend...
        uses: docker/build-push-action@v2
        with:
          context: "./backend/"
          file: "./backend/Dockerfile"
          push: true
          tags: |
            ${{ env.AWS_ECR_REPO_URL }}:latest
            ${{ env.AWS_ECR_REPO_URL }}:${{ github.ref_name }}
            ${{ env.AWS_ECR_REPO_URL }}:${{ needs.changes.outputs.short_sha }}

      - name: Update backend...
        working-directory: "./infrastructure/environments/dev/"
        env:
          TF_VAR_image_tag: ${{ needs.changes.outputs.short_sha }}
        run: |
          echo "Updating backend image..."
          terraform init
          terraform apply -auto-approve -target module.ecs.aws_ecs_service.api -target module.ecs.aws_ecs_task_definition.api

  frontend:
    name: Frontend
    needs: [changes, infrastructure, backend]
    if: |
      always() &&
      needs.changes.result == 'success' &&
      (needs.infrastructure.result == 'success' || needs.infrastructure.result == 'skipped') &&
      (needs.backend.result == 'success' || needs.backend.result == 'skipped') &&
      contains(needs.changes.outputs.changed_directories, 'frontend')
    runs-on: ubuntu-latest
    env:
      FRONTEND_DIRECTORY: "frontend"
    steps:

      - name: Download repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # OR "2" -> To retrieve the preceding commit.

      - name: Use Node.js 16.x
        uses: actions/setup-node@v1
        with:
          node-version: 16.x

      - name: Install dependencies
        run: npm install
        working-directory: "${{ FRONTEND_DIRECTORY }}"
      
      - name: Test
        run: npm test
        env:
          CI: true
        working-directory: "$FRONTEND_DIRECTORY"
      
      - name: Generate build
        run: npm run build
        working-directory: "$FRONTEND_DIRECTORY"

      - name: "Check if index.html exists..."
        id: check_files
        uses: andstor/file-existence-action@v1
        with:
          files: "./$FRONTEND_DIRECTORY/build/index.html"

      - name: "Fail if files dont exit"
        if: steps.check_files.outputs.files_exists != 'true'
        run: |
          ls -alh ./build
          echo "./$FRONTEND_DIRECTORY/build/index.html is missing!"
          exit 1

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: "us-east-2"

      - name: Deploy to S3
        run: aws s3 sync "./$FRONTEND_DIRECTORY/build/" s3://react-github-actions --dry-run --exclude docker --delete
        working-directory: "$FRONTEND_DIRECTORY"

      #- name: Invalidate Cache
      #  uses: chetan/invalidate-cloudfront-action@v2
      #  env:
      #    DISTRIBUTION: ${{ secrets.DEV_DISTRIBUTION }}
      #    PATHS: "/*"
      #    AWS_REGION: ${{ secrets.DEV_AWS_REGION }}
      #    AWS_ACCESS_KEY_ID: ${{ secrets.DEV_AWS_ACCESS_KEY_ID }}
      #    AWS_SECRET_ACCESS_KEY: ${{ secrets.DEV_AWS_SECRET_ACCESS_KEY }}
      #    DEBUG: "1"